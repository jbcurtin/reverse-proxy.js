<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">lib/server.js | Reverse-Proxy.js</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Simple reverse proxy server supporting WebSockets, implemented in JavaScript."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="Reverse-Proxy.js"><meta property="twitter:description" content="Simple reverse proxy server supporting WebSockets, implemented in JavaScript."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./" style="display: flex; align-items: center;"><img src="./image/brand_logo.png" style="width:34px;"></a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/cedx/reverse-proxy.js"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/application.js~Application.html">Application</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/server.js~Server.html">Server</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-EventEmitter">EventEmitter</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/server.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&apos;use strict&apos;;

const EventEmitter = require(&apos;events&apos;);
const {createServer, STATUS_CODES} = require(&apos;http&apos;);
const {createServer: createSecureServer} = require(&apos;https&apos;);
const {createProxyServer} = require(&apos;http-proxy&apos;);

/**
 * Acts as an intermediary for requests from clients seeking resources from other servers.
 */
exports.Server = class Server extends EventEmitter {

  /**
   * The default address that the server is listening on.
   * @type {string}
   */
  static get defaultAddress() {
    return &apos;0.0.0.0&apos;;
  }

  /**
   * The default port that the server is listening on.
   * @type {number}
   */
  static get defaultPort() {
    return 3000;
  }

  /**
   * Initializes a new instance of the class.
   * @param {object} [options] An object specifying values used to initialize this instance.
   */
  constructor(options = {}) {
    super();

    /**
     * The routing table.
     * @type {Map}
     */
    this.routes = new Map;
    if (&apos;routes&apos; in options) for (let [host, route] of Object.entries(options.routes)) this.routes.set(host, this._normalizeRoute(route));
    if (&apos;target&apos; in options) this.routes.set(&apos;*&apos;, this._normalizeRoute(options.target));

    /**
     * The underlying HTTP(S) service listening for requests.
     * @type {http~Server|https~Server}
     */
    this._httpService = null;

    /**
     * The server settings.
     * @type {object}
     */
    this._options = {
      address: typeof options.address == &apos;string&apos; ? options.address : Server.defaultAddress,
      port: Number.isInteger(options.port) ? Math.max(0, options.port) : Server.defaultPort,
      proxy: typeof options.proxy == &apos;object&apos; &amp;&amp; options.proxy ? options.proxy : null,
      ssl: typeof options.ssl == &apos;object&apos; &amp;&amp; options.ssl ? options.ssl : null
    };

    /**
     * The underlying proxy service providing custom application logic.
     * @type {ProxyServer}
     */
    this._proxyService = null;
  }

  /**
   * The class name.
   * @type {string}
   */
  get [Symbol.toStringTag]() {
    return &apos;Server&apos;;
  }

  /**
   * The address that the server is listening on.
   * @type {string}
   */
  get address() {
    return this.listening ? this._httpService.address().address : this._options.address;
  }

  /**
   * Value indicating whether the server is currently listening.
   * @type {boolean}
   */
  get listening() {
    return Boolean(this._httpService &amp;&amp; this._httpService.listening);
  }

  /**
   * The port that the server is listening on.
   * @type {number}
   */
  get port() {
    return this.listening ? this._httpService.address().port : this._options.port;
  }

  /**
   * Stops the server from accepting new connections. It does nothing if the server is already closed.
   * @return {Promise} Completes when the server is finally closed.
   * @emits {*} The &quot;close&quot; event.
   */
  async close() {
    return !this.listening ? null : new Promise(resolve =&gt; this._httpService.close(() =&gt; {
      this._httpService = null;
      this._proxyService = null;
      this.emit(&apos;close&apos;);
      resolve(null);
    }));
  }

  /**
   * Begin accepting connections. It does nothing if the server is already started.
   * @param {number} [port] The port that the server should run on.
   * @param {string} [address] The address that the server should run on.
   * @return {Promise&lt;number&gt;} The port that the server is running on.
   * @emits {*} The &quot;listening&quot; event.
   */
  async listen(port = this.port, address = this.address) {
    return this.listening ? this.port : new Promise((resolve, reject) =&gt; {
      this._proxyService = createProxyServer(this._options.proxy);
      this._proxyService.on(&apos;error&apos;, this._onRequestError.bind(this));

      let requestHandler = this._onHTTPRequest.bind(this);
      this._httpService = this._options.ssl ? createSecureServer(this._options.ssl, requestHandler) : createServer(requestHandler);
      this._httpService.on(&apos;upgrade&apos;, this._onWSRequest.bind(this));
      this._httpService.on(&apos;error&apos;, err =&gt; {
        this.emit(&apos;error&apos;, err);
        if (err.code == &apos;EADDRINUSE&apos;) reject(err);
      });

      this._httpService.listen(port, address, () =&gt; {
        this.emit(&apos;listening&apos;);
        resolve(this.port);
      });
    });
  }

  /**
   * Gets the host name contained in the headers of the specified request.
   * @param {http~IncomingMessage} req The request sent by the client.
   * @return {string} The host name provided by the specified request, or `*` if the host name could not be determined.
   */
  _getHostname(req) {
    let headers = req.headers;
    if (!(&apos;host&apos; in headers)) return &apos;*&apos;;

    let index = headers.host.indexOf(&apos;:&apos;);
    return index &lt; 0 ? headers.host : headers.host.substr(0, index);
  }

  /**
   * Normalizes the specified route.
   * @param {*} route The route to normalize.
   * @return {object} The normalized route.
   * @throws {Error} The route has an invalid format.
   */
  _normalizeRoute(route) {
    if (typeof route != &apos;object&apos; || !route) route = {uri: route};

    switch (typeof route.uri) {
      case &apos;number&apos;:
        route.uri = `http://127.0.0.1:${route.uri}`;
        break;

      case &apos;string&apos;:
        if (!/^https?:/i.test(route.uri)) route.uri = `http://${route.uri}`;
        break;

      default:
        throw new Error(&apos;The route has an invalid format.&apos;);
    }

    if (typeof route.headers != &apos;object&apos; || !route.headers) route.headers = {};
    else {
      let map = {};
      for (let [key, value] of Object.entries(route.headers)) map[key.toLowerCase()] = value;
      route.headers = map;
    }

    return route;
  }

  /**
   * Handles an HTTP request to a target.
   * @param {http~IncomingMessage} req The request sent by the client.
   * @param {http~ServerResponse} res The response sent by the server.
   * @emits {http~IncomingMessage} The &quot;request&quot; event.
   */
  _onHTTPRequest(req, res) {
    this.emit(&apos;request&apos;, req, res);

    let hostname = this._getHostname(req);
    let pattern = this.routes.has(hostname) ? hostname : &apos;*&apos;;
    if (!this.routes.has(pattern)) this._sendStatus(res, 404);
    else {
      let target = this.routes.get(pattern);
      Object.assign(req.headers, target.headers);
      this._proxyService.web(req, res, {target: target.uri});
    }
  }

  /**
   * Handles the error emitted if a request to a target fails.
   * @param {Error} err The emitted error event.
   * @param {http~IncomingMessage} req The request sent by the client.
   * @param {http~ServerResponse} res The response sent by the server.
   * @emits {Error} The &quot;error&quot; event.
   */
  _onRequestError(err, req, res) {
    this.emit(&apos;error&apos;, err);
    this._sendStatus(res, 502);
  }

  /**
   * Handles a WebSocket request to a target.
   * @param {http~IncomingMessage} req The request sent by the client.
   * @param {net~Socket} socket The network socket between the server and client.
   * @param {Buffer} head The first packet of the upgraded stream.
   */
  _onWSRequest(req, socket, head) {
    let hostname = this._getHostname(req);
    let pattern = this.routes.has(hostname) ? hostname : &apos;*&apos;;
    if (this.routes.has(pattern)) {
      let target = this.routes.get(pattern);
      Object.assign(req.headers, target.headers);
      this._proxyService.ws(req, socket, head, {target: target.uri});
    }
  }

  /**
   * Sends an HTTP status code and terminates the specified server response.
   * @param {http~ServerResponse} res The server response.
   * @param {number} statusCode The HTTP status code to send.
   */
  _sendStatus(res, statusCode) {
    let message = STATUS_CODES[statusCode];
    res.writeHead(statusCode, {
      &apos;Content-Length&apos;: Buffer.byteLength(message),
      &apos;Content-Type&apos;: &apos;text/plain; charset=utf-8&apos;
    });

    res.end(message);
  }
};
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.3)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
