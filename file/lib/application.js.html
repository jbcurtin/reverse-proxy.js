<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">lib/application.js | Reverse-Proxy.js</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Observable-based reverse proxy server supporting WebSockets, implemented in JavaScript."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="Reverse-Proxy.js"><meta property="twitter:description" content="Observable-based reverse proxy server supporting WebSockets, implemented in JavaScript."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./" style="display: flex; align-items: center;"><img src="./image/brand_logo.png" style="width:34px;"></a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/cedx/reverse-proxy.js"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/application.js~Application.html">Application</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/server.js~Server.html">Server</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/application.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&apos;use strict&apos;;

const program = require(&apos;commander&apos;);
const {readFile} = require(&apos;fs&apos;);
const {safeLoadAll: loadYAML} = require(&apos;js-yaml&apos;);
const morgan = require(&apos;morgan&apos;);
const {Observable} = require(&apos;rxjs&apos;);

const {version: pkgVersion} = require(&apos;../package.json&apos;);
const {Server} = require(&apos;./server&apos;);

/**
 * Represents an application providing functionalities specific to console requests.
 */
exports.Application = class Application {

  /**
   * The format used for logging the requests.
   * @type {string}
   */
  static get LOG_FORMAT() {
    return &apos;:req[host] :remote-addr - :remote-user [:date[clf]] &quot;:method :url HTTP/:http-version&quot; :status :res[content-length] &quot;:referrer&quot; &quot;:user-agent&quot;&apos;;
  }

  /**
   * Initializes a new instance of the class.
   */
  constructor() {

    /**
     * The proxy servers managed by this application.
     * @type {Server[]}
     */
    this.servers = [];
  }

  /**
   * Value indicating whether the application runs in debug mode.
   * @type {boolean}
   */
  get debug() {
    return [&apos;development&apos;, &apos;test&apos;].includes(this.env);
  }

  /**
   * The application environment.
   * @type {string}
   */
  get env() {
    return &apos;NODE_ENV&apos; in process.env ? process.env.NODE_ENV : &apos;development&apos;;
  }

  /**
   * Initializes the application.
   * @param {object} [args] The command line arguments.
   * @return {Observable} Completes when the initialization is over.
   */
  init(args = {}) {
    let observable;
    if (typeof args.config == &apos;string&apos;) {
      const loadConfig = Observable.bindNodeCallback(readFile);
      observable = loadConfig(args.config, &apos;utf8&apos;).mergeMap(data =&gt; this._parseConfig(data));
    }
    else observable = Observable.of([new Server({
      address: args.address,
      port: args.port,
      target: args.target
    })]);

    return observable.map(servers =&gt; this.servers = servers);
  }

  /**
   * Runs the application.
   * @return {Observable} Completes when the reverse proxy has been started.
   */
  run() {
    // Parse the command line arguments.
    const format = {
      asInteger: value =&gt; Number.parseInt(value, 10),
      asIntegerIfNumeric: value =&gt; /^\d+$/.test(value) ? Number.parseInt(value, 10) : value
    };

    program.name(&apos;reverse-proxy&apos;)
      .description(&apos;Simple reverse proxy server supporting WebSockets.&apos;)
      .version(pkgVersion, &apos;-v, --version&apos;)
      .option(&apos;-a, --address &lt;address&gt;&apos;, `address that the reverse proxy should run on [${Server.DEFAULT_ADDRESS}]`, Server.DEFAULT_ADDRESS)
      .option(&apos;-p, --port &lt;port&gt;&apos;, `port that the reverse proxy should run on [${Server.DEFAULT_PORT}]`, format.asInteger, Server.DEFAULT_PORT)
      .option(&apos;-t, --target &lt;target&gt;&apos;, &apos;location of the server the proxy will target&apos;, format.asIntegerIfNumeric)
      .option(&apos;-c, --config &lt;path&gt;&apos;, &apos;location of the configuration file for the reverse proxy&apos;)
      .option(&apos;-u, --user &lt;user&gt;&apos;, &apos;user to drop privileges to once server socket is bound&apos;, format.asIntegerIfNumeric)
      .option(&apos;--silent&apos;, &apos;silence the log output from the reverse proxy&apos;)
      .parse(process.argv);

    if (!program.config &amp;&amp; !program.target) program.help();

    // Start the proxy server.
    return this.init(program)
      .mergeMap(() =&gt; {
        if (!this.servers.length) return Observable.throw(new Error(&apos;Unable to find any configuration for the reverse proxy.&apos;));
        return this._startServers();
      })
      .do({complete: () =&gt; {
        if (program.user) this._setUser(program.user);
      }});
  }

  /**
   * Parses the specified configuration.
   * @param {string} data A string specifying the application configuration.
   * @return {Observable&lt;Server[]&gt;} The server instances corresponding to the parsed configuration.
   */
  _parseConfig(data) {
    data = data.trim();
    if (!data.length) return Observable.throw(new Error(&apos;Invalid configuration data.&apos;));

    /* eslint-disable no-extra-parens */
    let config;
    let firstChar = data[0];
    let lastChar = data[data.length - 1];
    let isJson = (firstChar == &apos;[&apos; &amp;&amp; lastChar == &apos;]&apos;) || (firstChar == &apos;{&apos; &amp;&amp; lastChar == &apos;}&apos;);
    /* eslint-enable no-extra-parens */

    try {
      if (!isJson) {
        config = [];
        loadYAML(data, options =&gt; config.push(options));
      }
      else {
        config = JSON.parse(data);
        if (!Array.isArray(config)) config = [config];
      }

      if (!config.every(value =&gt; typeof value == &apos;object&apos; &amp;&amp; value))
        throw new Error(&apos;Invalid configuration format.&apos;);
    }

    catch (err) {
      return Observable.throw(err);
    }

    const loadCert = Observable.bindNodeCallback(readFile);
    return Observable.from(config).mergeMap(options =&gt; {
      if (!(&apos;routes&apos; in options) &amp;&amp; !(&apos;target&apos; in options))
        return Observable.throw(new Error(&apos;You must provide at least a target or a routing table.&apos;));

      if (!(&apos;address&apos; in options)) options.address = program.address;
      if (!(&apos;port&apos; in options)) options.port = program.port;
      if (!(&apos;ssl&apos; in options)) return Observable.of(new Server(options));

      let keys = [&apos;ca&apos;, &apos;cert&apos;, &apos;key&apos;, &apos;pfx&apos;].filter(key =&gt; key in options.ssl);
      let observables = keys.map(key =&gt; loadCert(options.ssl[key]));
      return Observable.zip(...observables)
        .do(certs =&gt; { for (let i = 0; i &lt; keys.length; i++) options.ssl[keys[i]] = certs[i]; })
        .map(() =&gt; new Server(options));
    }).toArray();
  }

  /**
   * Sets the user identity of the application process.
   * @param {number|string} userId The user identifier.
   */
  _setUser(userId) {
    if (typeof process.setuid != &apos;function&apos;)
      console.error(&apos;Changing the process user is not supported on this platform.&apos;);
    else {
      console.log(`Drop user privileges to &quot;${userId}&quot;`);
      process.setuid(userId);
    }
  }

  /**
   * Starts the reverse proxy instances.
   * @return {Observable} Completes when all servers have been started.
   */
  _startServers() {
    let done = () =&gt; {};
    let logger = morgan(this.debug ? &apos;dev&apos; : Application.LOG_FORMAT);

    return Observable.merge(...this.servers.map(server =&gt; {
      server.onClose.subscribe(() =&gt; console.log(`Reverse proxy instance on ${server.address}:${server.port} closed`));
      server.onError.subscribe(error =&gt; console.error(this.debug ? error : error.message));
      server.onListening.subscribe(() =&gt; console.log(`Reverse proxy instance listening on ${server.address}:${server.port}`));
      if (!program.silent) server.onRequest.subscribe(({request, response}) =&gt; logger(request, response, done));

      return server.listen();
    }));
  }
};
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.1)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
